/************ CONFIG ************/
const SHEET_CONTRATOS = 'Contratos';
const SHEET_AUMENTOS  = 'Aumentos';
const SHEET_PAGOS     = 'Pagos';
const CACHE_NS        = 'b431f9ba59f6468e2bf5fb66610e07866ae4985e007859a209c415934c93200b';
const CACHE_TTL_SECS  = 300;

const HEADER_CONTRATOS = ['id','domicilio','inquilino','contacto','inicio','fin','precioMensual','aumento','periodicidad','ultimaActualizacion','notas'];
const HEADER_AUMENTOS  = ['id','contratoId','desde','hasta','porcentaje','nuevoPrecio','nota','createdAt'];
const HEADER_PAGOS     = ['id','contratoId','periodo','fechaPago','monto','metodo','nota','createdAt','updatedAt'];

/************ Multi-entorno ************/
// Ajust� los IDs en las propiedades del script (SPREADSHEET_ID_PROD, SPREADSHEET_ID_UAT, etc.)
// o complet� el objeto ENV_CONFIG directamente.
const DEFAULT_ENV = 'prod';
const SCRIPT_PROPS = PropertiesService.getScriptProperties();
const ENV_CONFIG = {
  prod: {
    spreadsheetId: (SCRIPT_PROPS.getProperty('SPREADSHEET_ID_PROD') || '').trim(),
  },
  uat: {
    spreadsheetId: (SCRIPT_PROPS.getProperty('SPREADSHEET_ID_UAT') || '').trim(),
  },
};

let runtimeEnv = DEFAULT_ENV;
let runtimeSpreadsheet = null;

function resolveEnvFromRequest(e) {
  const raw =
    (e && e.parameter && (e.parameter.env || e.parameter.environment || e.parameter.target)) || '';
  const name = String(raw).trim().toLowerCase();
  if (name && ENV_CONFIG[name]) return name;
  return DEFAULT_ENV;
}

function openSpreadsheetForEnv(envName) {
  const key = envName && ENV_CONFIG[envName] ? envName : DEFAULT_ENV;
  const cfg = ENV_CONFIG[key] || {};
  const id = (cfg.spreadsheetId || '').trim();
  if (id) {
    try {
      return SpreadsheetApp.openById(id);
    } catch (err) {
      if (key === DEFAULT_ENV) {
        return SpreadsheetApp.getActive();
      }
      throw err;
    }
  }
  if (key === DEFAULT_ENV) return SpreadsheetApp.getActive();
  throw new Error(`SpreadsheetId no configurado para el ambiente "${envName}".`);
}

function withEnvironment(envName, fn) {
  const previousEnv = runtimeEnv;
  const previousSpreadsheet = runtimeSpreadsheet;
  runtimeEnv = envName;
  runtimeSpreadsheet = openSpreadsheetForEnv(envName);
  try {
    return fn();
  } finally {
    runtimeEnv = previousEnv;
    runtimeSpreadsheet = previousSpreadsheet;
  }
}

function currentSpreadsheet() {
  if (runtimeSpreadsheet) return runtimeSpreadsheet;
  runtimeSpreadsheet = openSpreadsheetForEnv(runtimeEnv);
  return runtimeSpreadsheet;
}

function currentEnv() {
  return runtimeEnv || DEFAULT_ENV;
}

function cachePrefix() {
  return `${CACHE_NS}:${currentEnv()}`;
}

/************ Helpers ************/
function ensureSheet(name, header) {
  const ss = currentSpreadsheet();
  let sh = ss.getSheetByName(name);
  if (!sh) {
    sh = ss.insertSheet(name);
  }
  const curr = sh.getRange(1, 1, 1, header.length).getValues()[0];
  const mismatch = header.some((h, i) => curr[i] !== h);
  if (mismatch) {
    sh.getRange(1, 1, 1, header.length).setValues([header]);
  }
  return sh;
}

function sheet() { return ensureSheet(SHEET_CONTRATOS, HEADER_CONTRATOS); }
function sheetAum() { return ensureSheet(SHEET_AUMENTOS, HEADER_AUMENTOS); }
function sheetPagos() { return ensureSheet(SHEET_PAGOS, HEADER_PAGOS); }

function pad(n){ return String(n).padStart(2,'0'); }

function toYMD(x){
  if (!x) return '';
  if (x instanceof Date){
    return x.getFullYear() + '-' + pad(x.getMonth()+1) + '-' + pad(x.getDate());
  }
  if (typeof x === 'string'){
    const s = x.trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    let m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (m){
      const d = +m[1], mo = +m[2], y = +m[3];
      if (mo>=1 && mo<=12 && d>=1 && d<=31) return y + '-' + pad(mo) + '-' + pad(d);
    }
    m = s.match(/^(\d{4})[\/\.\-](\d{1,2})[\/\.\-](\d{1,2})$/);
    if (m){
      const y = +m[1], mo = +m[2], d = +m[3];
      if (mo>=1 && mo<=12 && d>=1 && d<=31) return y + '-' + pad(mo) + '-' + pad(d);
    }
  }
  const d = new Date(x);
  return isNaN(d) ? '' : (d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate()));
}

function toYM(x) {
  if (!x) return '';
  if (typeof x === 'string') {
    const s = x.trim();
    if (/^\d{4}-\d{2}$/.test(s)) return s;
    const iso = toYMD(s);
    return iso ? iso.slice(0, 7) : s.slice(0, 7);
  }
  const iso = toYMD(x);
  return iso ? iso.slice(0, 7) : '';
}

function currentPeriodYM() {
  const now = new Date();
  return now.getFullYear() + '-' + pad(now.getMonth() + 1);
}

function uniqueIds(list) {
  const out = [];
  const seen = {};
  (list || []).forEach((value) => {
    const key = String(value || '').trim();
    if (!key || seen[key]) return;
    seen[key] = true;
    out.push(key);
  });
  return out;
}

function parseIdsParam(value) {
  if (value == null) return [];
  if (Array.isArray(value)) return uniqueIds(value);
  const text = String(value).trim();
  if (!text) return [];
  if (text[0] === '[' && text[text.length - 1] === ']') {
    try {
      const parsed = JSON.parse(text);
      if (Array.isArray(parsed)) return uniqueIds(parsed);
    } catch (err) {
      // ignore parsing error, fallback to splitting
    }
  }
  return uniqueIds(text.split(/[\s,;]+/));
}

function nextBusinessDay(date) {
  const base = date instanceof Date ? new Date(date) : new Date(date);
  if (!base || isNaN(base.getTime())) return null;
  const adjusted = new Date(base);
  let weekday = adjusted.getDay();
  while (weekday === 0 || weekday === 6) {
    adjusted.setDate(adjusted.getDate() + 1);
    weekday = adjusted.getDay();
  }
  return adjusted;
}

function paymentDueDate(periodo, day) {
  if (!periodo) return '';
  const parts = String(periodo).slice(0, 7).split('-');
  const y = Number(parts[0]);
  const m = Number(parts[1]);
  if (!y || !m) return '';
  const base = new Date(y, m - 1, Number(day || 10));
  const adjusted = nextBusinessDay(base);
  return adjusted ? toYMD(adjusted) : '';
}

function normalizeRow(header, row){
  const out = {};
  for (let i=0;i<header.length;i++){
    const h = header[i], v = row[i];
    if (h === 'inicio' || h === 'fin' || h === 'ultimaActualizacion'){
      out[h] = toYMD(v);
    } else {
      out[h] = (v === undefined || v === null) ? '' : v;
    }
  }
  return out;
}

function forceText(x) {
  if (x === undefined || x === null) return '';
  const s = String(x).trim();
  return /^\d/.test(s) ? "'" + s : s; // evita que Sheets lo transforme en fecha
}

function asCellContrato(h, v) {
  if (h === 'inicio' || h === 'fin' || h === 'ultimaActualizacion') return toYMD(v);
  if (h === 'precioMensual') return v ?? '';
  return forceText(v);
}

function asCellAum(h, v) {
  if (h === 'desde' || h === 'hasta') return toYMD(v);
  if (h === 'nuevoPrecio' || h === 'basePrecio') return v ?? '';
  if (h === 'porcentaje') return forceText(v); // <-- clave
  return forceText(v);
}

function asCellPago(h, v) {
  if (h === 'periodo') return toYM(v);
  if (h === 'fechaPago' || h === 'createdAt' || h === 'updatedAt') return toYMD(v);
  if (h === 'monto') return v ?? '';
  return forceText(v);
}

function ensureHeader() {
  sheet();
  sheetAum();
  sheetPagos();
}

function validateContrato(item){
  const i = toYMD(item.inicio);
  const f = toYMD(item.fin);
  if (i && f && new Date(i) > new Date(f)) return 'inicio no puede ser mayor a fin';
  if (i) item.inicio = i;
  if (f) item.fin = f;
  return null;
}

function json(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function out(obj, callback) {
  const text = JSON.stringify(obj);
  if (callback) {
    return ContentService
      .createTextOutput(`${callback}(${text});`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService
    .createTextOutput(text)
    .setMimeType(ContentService.MimeType.JSON);
}

function parseItemParam(e) {
  try { return e.parameter.item ? JSON.parse(e.parameter.item) : null; }
  catch { return null; }
}

function cache() {
  return CacheService.getScriptCache();
}

/************ Router ************/
function doGet(e) {
  return withEnvironment(resolveEnvFromRequest(e), () => {
    ensureHeader();
    const action = (e.parameter.action || 'list').toLowerCase();
    const cb = e.parameter.callback || null;

    if (action === 'list')      return out(listData(), cb);

    if (action === 'get')       return out(getByIdData(e.parameter.id), cb);
    if (action === 'create')    return out(createData(parseItemParam(e)), cb);
    if (action === 'update')    return out(updateData(parseItemParam(e)), cb);
    if (action === 'delete')    return out(removeData(e.parameter.id), cb);

    if (action === 'listaum')   return out(listAumData(e.parameter.contratoId), cb);
    if (action === 'createaum') return out(createAumData(parseItemParam(e)), cb);
    if (action === 'updateaum') return out(updateAumData(parseItemParam(e)), cb);
    if (action === 'deleteaum') return out(removeAumData(e.parameter.id), cb);

    if (action === 'listpagos')  return out(listPagosData(e.parameter.contratoId), cb);
    if (action === 'statuspagos') {
      const idsParam = e.parameter.ids || e.parameter.id || e.parameter.contratoId || e.parameter.contratoid;
      return out(statusPagosData(idsParam, e.parameter.periodo || e.parameter.period), cb);
    }
    if (action === 'estadopago') return out(statePagoData(e.parameter.contratoId), cb);
    if (action === 'createpago') return out(createPagoData(parseItemParam(e)), cb);
    if (action === 'updatepago') return out(updatePagoData(parseItemParam(e)), cb);
    if (action === 'deletepago') return out(removePagoData(e.parameter.id), cb);

    return out({ ok:false, error:'Action not found' }, cb);
  });
}

/************ Contratos ************/
function listData(){
  const sh = sheet();
  const lastRow = sh.getLastRow(), lastCol = sh.getLastColumn();
  const values = lastRow ? sh.getRange(1,1,lastRow,lastCol).getValues() : [[]];
  const [header, ...rows] = values;

  // Calcular último precio por contrato leyendo Aumentos UNA vez
  const sha = sheetAum();
  const aLastRow = sha.getLastRow(), aLastCol = sha.getLastColumn();
  const aValues = aLastRow ? sha.getRange(1,1,aLastRow,aLastCol).getValues() : [[]];
  const [hA, ...rowsA] = aValues;
  const idxA = Object.fromEntries(hA.map((h,i)=>[h,i]));
  const today = new Date();
  today.setHours(0,0,0,0);
  const lastByContrato = {}; // contratoId -> {ts, precio}
  const aumentosByContrato = {};

  rowsA.forEach((r) => {
    const cid = String(r[idxA.contratoId] || "").trim();
    if (!cid) return;
    const np = Number(r[idxA.nuevoPrecio] || 0);
    const desdeStr = toYMD(r[idxA.desde]);
    const hastaStr = toYMD(r[idxA.hasta]);
    const hastaDate = hastaStr ? new Date(hastaStr) : new Date(0);
    const ts =
      hastaDate.getTime() ||
      (r[idxA.createdAt] ? new Date(r[idxA.createdAt]).getTime() : 0);
    if (!lastByContrato[cid] || ts > lastByContrato[cid].ts) {
      lastByContrato[cid] = { ts, precio: np };
    }
    if (!aumentosByContrato[cid]) aumentosByContrato[cid] = [];
    aumentosByContrato[cid].push({
      desde: desdeStr,
      hasta: hastaStr,
      precio: np,
    });
  });

  const currentByContrato = {};
  Object.keys(aumentosByContrato).forEach((cid) => {
    const list = aumentosByContrato[cid];
    let best = null;
    list.forEach((entry) => {
      if (!entry.desde) return;
      const desdeDate = new Date(entry.desde);
      if (isNaN(desdeDate.getTime())) return;
      if (desdeDate > today) return;
      if (!best || desdeDate > best.date) {
        best = { date: desdeDate, precio: entry.precio, desde: entry.desde };
      }
    });
    if (best) currentByContrato[cid] = best;
  });

  const items = rows
    .filter(r => r[0])
    .map(r => {
      const obj = normalizeRow(header, r);
      const base = Number(obj.precioMensual || 0);
      const lp = lastByContrato[obj.id]?.precio;
      obj.lastPrecio = (lp != null && !isNaN(lp)) ? lp : base;
      const currentInfo = currentByContrato[obj.id];
      if (currentInfo && Number.isFinite(currentInfo.precio)) {
        obj.currentPrecio = currentInfo.precio;
        obj.currentPrecioDesde = currentInfo.desde || obj.inicio || '';
      } else {
        obj.currentPrecio = base;
        obj.currentPrecioDesde = obj.inicio || '';
      }
      return obj;
    });

  return { items };
}

function getByIdData(id){
  const sh = sheet();
  const lr = sh.getLastRow(), lc = sh.getLastColumn();
  if (!lr) return { item:null };
  const values = sh.getRange(1,1,lr,lc).getValues();
  const [header, ...rows] = values;
  const row = rows.find(r => String(r[0]) === String(id));
  return { item: row ? normalizeRow(header, row) : null };
}

function createData(item){
  if (!item) return { ok:false, error:'Bad item' };
  const err = validateContrato(item); if (err) return { ok:false, error:err };
  const sh = sheet();
  const header = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  item.id = item.id || String(Date.now());
  const row = header.map(h => asCellContrato(h, item[h]));
  sh.appendRow(row);
  return { ok:true, id:item.id };
}

// ► update más rápido: localizar fila por ID con TextFinder
function updateData(item){
  if (!item || !item.id) return { ok:false, error:'Bad item' };
  const err = validateContrato(item); if (err) return { ok:false, error:err };
  const sh = sheet();
  const finder = sh.getRange('A:A').createTextFinder(String(item.id)).matchEntireCell(true).findNext();
  if (!finder) return { ok:false, error:'Not found' };
  const rowNum = finder.getRow();
  const header = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const prev = sh.getRange(rowNum,1,1,header.length).getValues()[0];
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  const merged = header.map(h => (item[h] !== undefined) ? asCellContrato(h, item[h]) : prev[idx[h]]);
  sh.getRange(rowNum, 1, 1, merged.length).setValues([merged]);
  return { ok:true };
}

// ► delete más rápido: localizar fila por ID con TextFinder
function removeData(id) {
  const sh = sheet();
  const finder = sh.getRange('A:A').createTextFinder(String(id)).matchEntireCell(true).findNext();
  if (!finder) return { ok:false, error:'Not found' };
  sh.deleteRow(finder.getRow());
  return { ok:true };
}

/************ Aumentos ************/
function listAumData(contratoId){
  const sha = sheetAum();
  const lr = sha.getLastRow(), lc = sha.getLastColumn();
  if (!lr) return { items: [] };
  const values = sha.getRange(1,1,lr,lc).getValues();
  const [h, ...rows] = values;
  const idx = Object.fromEntries(h.map((x,i)=>[x,i]));
  const items = rows
    .filter(r => r[idx.contratoId] && String(r[idx.contratoId]) === String(contratoId))
    .map(r => {
      const o = {};
      h.forEach((key, i) => {
        if (key === 'desde' || key === 'hasta') o[key] = toYMD(r[i]);
        else o[key] = r[i] ?? '';
      });
      return o;
    });
  items.sort((a,b) => new Date(a.hasta) - new Date(b.hasta));
  return { items };
}

function createAumData(item){
  if (!item) return { ok:false, error:'Bad item' };
  const sha = sheetAum();
  const header = sha.getRange(1,1,1,sha.getLastColumn()).getValues()[0];
  item.id = item.id || String(Date.now());
  item.createdAt = item.createdAt || new Date();
  const row = header.map(h => asCellAum(h, item[h]));
  sha.appendRow(row);
  return { ok:true, id:item.id };
}

function updateAumData(item){
  if (!item || !item.id) return { ok:false, error:'Bad item' };
  const sha = sheetAum();
  const finder = sha.getRange('A:A').createTextFinder(String(item.id)).matchEntireCell(true).findNext();
  if (!finder) return { ok:false, error:'Not found' };
  const rowNum = finder.getRow();
  const header = sha.getRange(1,1,1,sha.getLastColumn()).getValues()[0];
  const prev = sha.getRange(rowNum,1,1,header.length).getValues()[0];
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  const merged = header.map(h => (item[h] !== undefined) ? asCellAum(h, item[h]) : prev[idx[h]]);
  sha.getRange(rowNum, 1, 1, merged.length).setValues([merged]);
  return { ok:true };
}

function removeAumData(id){
  const sha = sheetAum();
  const finder = sha.getRange('A:A').createTextFinder(String(id)).matchEntireCell(true).findNext();
  if (!finder) return { ok:false, error:'Not found' };
  sha.deleteRow(finder.getRow());
  return { ok:true };
}

/************ Pagos ************/
function listPagosData(contratoId){
  const shp = sheetPagos();
  const lastRow = shp.getLastRow(), lastCol = shp.getLastColumn();
  if (lastRow < 2) return { items: [] };
  const values = shp.getRange(1, 1, lastRow, lastCol).getValues();
  const [header, ...rows] = values;
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  const target = contratoId ? String(contratoId).trim() : '';

  const items = rows
    .filter(r => r[idx.id])
    .filter(r => !target || String(r[idx.contratoId] || '').trim() === target)
    .map(r => {
      const o = {};
      header.forEach((key, colIdx) => {
        const val = r[colIdx];
        if (key === 'periodo') {
          o[key] = toYM(val);
        } else if (key === 'fechaPago' || key === 'createdAt' || key === 'updatedAt') {
          o[key] = toYMD(val);
        } else if (key === 'monto') {
          o[key] = Number(val || 0);
        } else {
          o[key] = val ?? '';
        }
      });
      if (!o.periodo) o.periodo = toYM(o.fechaPago);
      return o;
    });

  items.sort((a, b) => {
    const p = (a.periodo || '').localeCompare(b.periodo || '');
    if (p !== 0) return p;
    return (a.fechaPago || '').localeCompare(b.fechaPago || '');
  });

  return { items };
}

function createPagoData(item){
  if (!item) return { ok:false, error:'Bad item' };
  if (!item.contratoId) return { ok:false, error:'contratoId requerido' };
  const shp = sheetPagos();
  const now = new Date();
  item.id = item.id || String(Date.now());
  item.periodo = toYM(item.periodo || item.fechaPago || now);
  item.fechaPago = toYMD(item.fechaPago || now);
  item.monto = Number(item.monto ?? 0) || 0;
  item.createdAt = toYMD(item.createdAt || now);
  item.updatedAt = toYMD(now);
  const row = HEADER_PAGOS.map((h) => asCellPago(h, item[h]));
  shp.appendRow(row);
  return { ok:true, id:item.id };
}

function updatePagoData(item){
  if (!item || !item.id) return { ok:false, error:'Bad item' };
  const shp = sheetPagos();
  const finder = shp.getRange('A:A').createTextFinder(String(item.id)).matchEntireCell(true).findNext();
  if (!finder) return { ok:false, error:'Not found' };
  const rowNum = finder.getRow();
  const header = HEADER_PAGOS;
  const prev = shp.getRange(rowNum, 1, 1, header.length).getValues()[0];
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));

  if (item.periodo !== undefined) item.periodo = toYM(item.periodo || prev[idx.periodo]);
  if (item.fechaPago !== undefined) item.fechaPago = toYMD(item.fechaPago || prev[idx.fechaPago]);
  if (item.monto !== undefined) item.monto = Number(item.monto ?? 0) || 0;
  item.updatedAt = toYMD(new Date());

  const merged = header.map((h) => {
    if (item[h] !== undefined) return asCellPago(h, item[h]);
    return prev[idx[h]];
  });

  shp.getRange(rowNum, 1, 1, header.length).setValues([merged]);
  return { ok:true };
}

function removePagoData(id){
  const shp = sheetPagos();
  const finder = shp.getRange('A:A').createTextFinder(String(id)).matchEntireCell(true).findNext();
  if (!finder) return { ok:false, error:'Not found' };
  shp.deleteRow(finder.getRow());
  return { ok:true };
}

function paymentStatusFor(contratoId, periodo) {
  const shp = sheetPagos();
  const lastRow = shp.getLastRow(), lastCol = shp.getLastColumn();
  const out = { total: 0, pagado: 0, saldo: 0, vencimiento: '' };
  if (lastRow < 2) return out;
  const values = shp.getRange(1,1,lastRow,lastCol).getValues();
  const [header, ...rows] = values;
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  const target = String(contratoId).trim();

  rows
    .filter(r => String(r[idx.contratoId] || '').trim() === target)
    .forEach(r => {
      const currentPeriodo = toYM(r[idx.periodo] || r[idx.fechaPago]);
      if (currentPeriodo !== periodo) return;
      if (!out.vencimiento) out.vencimiento = toYMD(r[idx.vencimiento] || r[idx.fechaPago]);
      const maybeTotal = Number(r[idx.montoTotal] || r[idx.total] || 0);
      if (maybeTotal > out.total) out.total = maybeTotal;
      out.pagado += Number(r[idx.monto] || 0);
    });

  return out;
}

function statusPagosData(idsParam, periodoParam) {
  const ids = uniqueIds(Array.isArray(idsParam) ? idsParam : parseIdsParam(idsParam));
  const periodo = toYM(periodoParam || currentPeriodYM()) || currentPeriodYM();
  if (!ids.length) return { periodo, items: {} };

  const cacheSvc = cache();
  const prefix = cachePrefix();
  const cacheKeys = ids.map((id) => `${prefix}:status:${periodo}:${id}`);
  const cachedEntries = cacheSvc.getAll(cacheKeys);
  const results = {};
  const missing = [];

  ids.forEach((id, idx) => {
    const cacheKey = cacheKeys[idx];
    const cached = cachedEntries && cachedEntries[cacheKey];
    if (cached) {
      try {
        results[id] = JSON.parse(cached);
        return;
      } catch (err) {
        // cache corrupt, recompute
      }
    }
    missing.push({ id, cacheKey });
  });

  if (missing.length) {
    const shp = sheetPagos();
    const lastRow = shp.getLastRow();
    const lastCol = shp.getLastColumn();
    let rows = [];
    let header = [];
    if (lastRow >= 2) {
      const values = shp.getRange(1, 1, lastRow, lastCol).getValues();
      header = values[0] || [];
      rows = values.slice(1);
    }
    const idx = Object.fromEntries((header || []).map((h, i) => [h, i]));
    const colContrato = idx.contratoId;
    const colPeriodo = idx.periodo;
    const colFechaPago = idx.fechaPago;
    const colMonto = idx.monto;
    const colTotal = idx.montoTotal != null ? idx.montoTotal : idx.total;
    const colVenc = idx.vencimiento;

    const targetIds = new Set(missing.map((m) => m.id));
    const aggregated = {};

    if (rows.length && colContrato != null) {
      rows.forEach((row) => {
        const contratoId = String(row[colContrato] || '').trim();
        if (!contratoId || !targetIds.has(contratoId)) return;

        const periodoValue =
          colPeriodo != null ? row[colPeriodo] : (colFechaPago != null ? row[colFechaPago] : '');
        const currentPeriodo = toYM(periodoValue);
        if (currentPeriodo !== periodo) return;

        const entry = aggregated[contratoId] || { total: 0, pagado: 0, vencimiento: '' };
        if (!entry.vencimiento) {
          const venc = colVenc != null ? row[colVenc] : null;
          const fecha = colFechaPago != null ? row[colFechaPago] : null;
          entry.vencimiento = toYMD(venc || fecha);
        }
        if (colTotal != null) {
          const maybeTotal = Number(row[colTotal] || 0);
          if (Number.isFinite(maybeTotal) && maybeTotal > entry.total) {
            entry.total = maybeTotal;
          }
        }
        if (colMonto != null) {
          entry.pagado += Number(row[colMonto] || 0);
        }
        aggregated[contratoId] = entry;
      });
    }

    // fallback totals desde contratos
    let contractLookup = {};
    const shContratos = sheet();
    const lastRowContratos = shContratos.getLastRow();
    if (lastRowContratos >= 2) {
      const valuesC = shContratos
        .getRange(1, 1, lastRowContratos, shContratos.getLastColumn())
        .getValues();
      const [headerC, ...rowsC] = valuesC;
      const idxC = Object.fromEntries((headerC || []).map((h, i) => [h, i]));
      const colId = idxC.id;
      const colPrecio = idxC.precioMensual;
      if (colId != null && colPrecio != null) {
        contractLookup = rowsC.reduce((acc, row) => {
          const id = String(row[colId] || '').trim();
          if (!id) return acc;
          acc[id] = Number(row[colPrecio] || 0);
          return acc;
        }, {});
      }
    }

    const cacheEntries = {};
    missing.forEach(({ id, cacheKey }) => {
      const base = aggregated[id] || { total: 0, pagado: 0, vencimiento: '' };
      let total = Number(base.total || 0);
      const pagado = Number(base.pagado || 0);
      if (!total) total = Number(contractLookup[id] || 0);
      const saldo = Math.max(total - pagado, 0);
      const vencimiento = base.vencimiento || paymentDueDate(periodo);
      let status = 'pending';
      if (saldo <= 0 && total > 0) status = 'paid';
      else if (pagado > 0) status = 'partial';
      const payload = { status, periodo, total, pagado, saldo, vencimiento };
      results[id] = payload;
      cacheEntries[cacheKey] = JSON.stringify(payload);
    });

    if (Object.keys(cacheEntries).length) {
      cacheSvc.putAll(cacheEntries, CACHE_TTL_SECS);
    }
  }

  return { periodo, items: results };
}

function statePagoData(contratoId) {
  const keyId = String(contratoId || '').trim();
  if (!keyId) return { status: 'unknown' };
  const periodo = currentPeriodYM();
  const { items } = statusPagosData([keyId], periodo);
  if (items && items[keyId]) return items[keyId];
  return {
    status: 'pending',
    periodo,
    total: 0,
    pagado: 0,
    saldo: 0,
    vencimiento: paymentDueDate(periodo),
  };
}
